<!DOCTYPE html>
<html>

<head><meta name="generator" content="Hexo 3.8.0">
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<meta name="theme-color" content="#33474d">
	<title>Von Weber&#39;s Blog</title>
	<link rel="stylesheet" href="/css/style.css">
	
      <link rel="alternate" href="/atom.xml" title="Von Weber&#39;s Blog" type="application/atom+xml">
	
	
	<script type="text/x-mathjax-config">
		MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
	</script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML" async></script>

</head>

<body>

	<header class="header">
		<nav class="header__nav">
			
				<a href="/archives" class="header__link">Archive</a>
			
				<a href="/tags" class="header__link">Tags</a>
			
				<a href="/atom.xml" class="header__link">RSS</a>
			
		</nav>
		<h1 class="header__title"><a href="/">Von Weber&#39;s Blog</a></h1>
		<h2 class="header__subtitle">No models are correct, but some are more elegant than others.</h2>
	</header>

	<main>
		



	<article>
	
		<h1><a href="/2018/11/05/ARS-Adaptive-Rejection-Sampling/">ARS (Adaptive Rejection Sampling)</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2018-11-05</span><br>
		
		
			<span class="article__tags">
			  	<a class="article__tag-link" href="/tags/C/">C</a> <a class="article__tag-link" href="/tags/统计/">统计</a> <a class="article__tag-link" href="/tags/统计计算/">统计计算</a> <a class="article__tag-link" href="/tags/随机数产生/">随机数产生</a>
			</span>
		
	</div>

	

	
		<p>ARS (Adaptive Rejection Sampling) 是一种生成具有对数凹密度 (log-concave density)的随机数的方法，ARS使用包围的接受拒绝 (Envelope Accept-Reject) 方法，而Envelope接受拒绝方法是一般接受拒绝方法的一个变形（改进）。</p>
<h2 id="Envelope-Accept-Reject"><a href="#Envelope-Accept-Reject" class="headerlink" title="Envelope Accept-Reject"></a>Envelope Accept-Reject</h2><p>和普通的接受拒绝方法相比，EAR多了一个下界，即，若存在密度$g_m$，函数$g_l$和正常数$M$满足<br>$$g_l(x) \leq f(x) \leq Mg_m(x),$$<br>则下列算法产生随机变量服从分布$f$</p>
<ol>
<li>生成 $X \sim g_m(x), U \sim \mathcal{U}_{[0,1]}$</li>
<li>IF  $U \leq g_l(X)/Mg_m(X)$</li>
<li>THEN 接受$X$</li>
<li>ELSEIF  $U \leq f(X)/Mg_m(X)$</li>
<li>THEN 接受$X$</li>
</ol>
<p>这个算法的成立是显然的，若有$U \leq g_l(X)/Mg_m(X)$，必有$U \leq f(X)/Mg_m(X)$，所以和普通的接受拒绝方法相比，EAR可能在第3行就结束，而不用计算$f(x)$的值，这个优点当$f(x)$很难计算时便很有用。</p>
<p>当然EAR并不能完全避免计算$f(x)$的值，具体来讲，节省的比例为<br>$$\begin{align}<br>P(U \leq g_l(X)/Mg_m(x)) &amp;= E[P(U \leq g_l(X)/Mg_m(X) | X)] \\<br>                         &amp;= E[g_l(X)/Mg_m(X)] \\<br>                         &amp;= \frac{1}{M} \int{g_m(x)dx}<br>\end{align}$$</p>
<p>值得一提的是，上述的函数$g_l, f, g_m$，都可以之多差一个系数，但是这样的话，常数$M$不再具有上述的含义。以正态分布$N(0,1)$为例，略去常数，取 $f(x)=\exp (-x^2/2)$。由泰勒公式，<br>$$e^{-x^2/2} \geq 1-\frac{x^2}{2}$$<br>于是可取<br>$$g_l(x) = \left (1-\frac{x^2}{2} \right ) \lor 0$$<br>另一方面若取$g_m(x)$为Laplace(1)分布，即$g_m(x)=\lambda /2 \exp (-\lambda x), \lambda=1$，则容易计算接受率为76%，引入Envelope下界，可避免58%的$f(x)$的计算，对于复杂的目标密度，这个节省还是很可观。</p>
<h2 id="Adaptive-Rejection-Sampling"><a href="#Adaptive-Rejection-Sampling" class="headerlink" title="Adaptive Rejection Sampling"></a>Adaptive Rejection Sampling</h2><p>自适应拒绝采样(ARS)的想法很简单，基于上述EAR的思路，对于具有对数凹密度的随机变量，由凹函数的几何性质，很容易构造出自适应的Envelope上下界，准确来讲是构造分段线性函数的上下界。</p>
<p><figure class="figure"><img src="/img/ARS.svg" alt="图 1. ARS算法"><figcaption class="figure__caption">图 1. ARS算法</figcaption></figure></p>
<p>如上图所示，设 $h=\log f$ 凹，$S_n = \{x_i, i=0,1,…,n+1\}$ 是一列从小到大的 $f$ 支撑上的点。由 $h$ 的凹性，直线 $L_{i,i+1}$ 穿过点 $(x_i,h(x_i))$ 和点 $(x_{i+1},h(x_{i+1}))$，在区间 $[x_i,x_{i+1}]$ 上在 $h$ 的下方，在这个区间外在 $h$ 的上方，于是我们定义<br>$$ \overline{h}_n (x) = \min \{ L_{i-1,i}(x), L_{i+1,i+2}(x) \}$$</p>
<p>如上图红线，定义<br>$$\underline{h}_n(x) = L_{i,i+1}(x)$$</p>
<p>如上图蓝线所示。在集合 $[ x_0,x_{n+1} ]^c$ 上补充<br>$$\underline{h}_n(x) = - \infty, \quad \overline{h}_n (x) = \min \{ L_{0,1}(x), L_{n,n+1}(x)$$<br>这样，在 $f$ 的支撑上成立<br>$$\underline{h}_n(x) \leq h(x) \leq \overline{h}_n (x)$$<br>最后取指数，即 $\underline{f}_n(x) = \exp \underline{h}_n(x)$，$\overline{f}_n(x) = \exp \overline{h}_n(x)$，有<br>$$\underline{f}_n(x) \leq f(x) \leq \overline{f}_n (x)= \varpi g_n(x)$$<br>最右边的等号表示，将 $\overline{f}_n(x)$ 归一化为密度函数，$\varpi$是正规化常数。</p>
<p>这样我们得到了Envelope的上下界，带入到EAR算法中，我们得到如下的ARS算法</p>
<ol start="0">
<li>初始化 $n$ 和 $S_n$</li>
<li>生成 $X \sim g_n(x), U \sim \mathcal{U}_{[ 0,1 ]}$</li>
<li>IF $U \leq \underline{f}_n(X) / \varpi g_n(X)$</li>
<li>THEN 接受 $X$</li>
<li>ELSEIF $U \leq f(X) / \varpi g_n(X)$</li>
<li>THEN 接受 $X$</li>
<li>$\qquad$更新 $S_n \to S_{n+1}=S_n \cup \{ X \}$</li>
</ol>
<p>ARS算法在生成随机数过程中会不断更新 $S_n$，使得Envelope上下界越来越接近 $f$，算法的效率越来越高，体现在接受率越来越接近1,和计算 $f(x)$ 的频率越来越少（趋近于0）。</p>
<p>另外要指出的是，算法中的常数 $\varpi$ 并不用计算，因为 $\varpi$ 总是和 $g_n(X)$ 一起，而 $\varpi g_n(X) = \overline{f}_n (x)$。</p>
<p>到此为止，ARS算法只差的步骤1的生成 $X \sim g_n(X)$，它被解决如下</p>
<h2 id="Generate-X-sim-g-n-x"><a href="#Generate-X-sim-g-n-x" class="headerlink" title="Generate $X \sim g_n(x)$"></a>Generate $X \sim g_n(x)$</h2><p>$g_n(x)$ 是分段函数，我们将它重新写成<br>$$g_n(x) = \varpi^{-1} \left \{ \sum_{i=0}^{r_n} e^{\alpha_i x + \beta_i} \Bbb{I}_{[ x_i,x_{i+1} ]}(x) +<br>e^{\alpha_{-1} x + \beta_{-1}} \Bbb{I}_{[- \infty,x_0]}(x) +<br>e^{\alpha_{r_n+1} x + \beta_{r_n+1}} \Bbb{I}_{[x_n+1,+ \infty]}(x) \right \}$$</p>
<p>其中 $y=\alpha_i x + \beta_i$ 对应区间 $[ x_i,x_i+1 ]$，这其中包括相邻两个线段的交点，直线 $y=\alpha_i x + \beta_i$ 和 $y=\alpha_{i+1} x + \beta_{i+1}$ 的交点在 $x=-(\beta_{i+1}-\beta_i)/(\alpha_{i+1}-\alpha_i)$ 处。$y=\alpha_{-1} x + \beta_{-1}$ 和 $y=\alpha_{r_n+1} x + \beta_{r_n+1}$ 分别对应区间 $[- \infty, x_0]$ 和 $ [ x_{n+1}, + \infty ]$， $r_n$ 表示线段的数量</p>
<p>由 $\varpi g_n(X) = \overline{f}_n (x)$，两边积分可得<br>$$\begin{align} \varpi_n &amp;= \int_{- \infty}^{x_0} e^{\alpha_{-1} x + \beta_{-1}} dx +<br>\sum_{i=0}^{r_n} \int_{x_i}^{x_{i+1}} e^{\alpha_{i} x + \beta_{i+1}} dx +<br>\int_{x_{n+1}}^{+ \infty} e^{\alpha_{r_n+1} x + \beta_{r_n+1}} dx \\<br>&amp;= \frac{e^{\alpha_{-1} x_0 + \beta_{-1}}}{\alpha_{-1}} +<br>\sum_{i=0}^{r_n}  e^{\beta_i} \frac{\alpha_{i} x_{i+1} - \alpha_{i} x_{i}}{\alpha_{i}} -<br>\frac{\alpha_{r_n+1} x_{n+1}}{\alpha_{r_n+1}}<br>\end{align}$$</p>
<p>由上面的计算知道，$g_n(x)$ 在区间 $[ x_i,x_{i+1} ]$ 上的概率<br>$$\omega_i = \begin{cases}<br>\frac{e^{\alpha_{-1} x_0 + \beta_{-1}}}{ \varpi \alpha_{-1}} &amp;\text{if } i=-1, \\<br>e^{\beta_i} \frac{\alpha_{i} x_{i+1} - \alpha_{i} x_{i}}{\varpi \alpha_{i}} &amp;\text{if } 0 \leq i \leq r_n, \\<br>-\frac{\alpha_{r_n+1} x_{n+1}}{\varpi \alpha_{r_n+1}} &amp;\text{if } i = r_n+1.<br>\end{cases}$$</p>
<p>其中 $ x_{-1}=- \infty, x_{r_n+2}=+ \infty$。利用逆分布分布函数方法，注意到若 $ X \sim g_n(x)$，则 $X|x_i \leq X \leq x_{i+1} \sim h(x)=c^{-1} \exp \{ \alpha_i x +\beta_i \} $，其中 $ c=\alpha^{-1} ( e^{\alpha_i x_{i+1} +\beta_i} -e^{\alpha_i x_{i} +\beta_i} )$，我们得到如下的算法生成随机变量 $X \sim g_n(x)$</p>
<ol>
<li>依概率 $\omega_i$ 选择区间 $[ x_i,x_{i+1} ]$ </li>
<li>生成 $U \sim \mathcal{U}_{[ 0,1 ]}$，取<br>$$ X = \alpha^{-1} \log [ e^{\alpha_i x_i} + U (e^{\alpha_i x_{i+1}} - e^{\alpha_i x_i}) ]$$</li>
</ol>
<h2 id="ARS算法的C语言实现"><a href="#ARS算法的C语言实现" class="headerlink" title="ARS算法的C语言实现"></a>ARS算法的C语言实现</h2><p>基于上述描述，我们用C语言实现ARS算法，由于算法中涉及许多动态动态内存的操作，考虑到结构化和性能的平衡，我们设计程序的结构如下。</p>
<p>首先是保存一个线段的结构 <code>Segment</code>，包含线段的始末横坐标，斜率，截距和取完指数后的积分。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> x1, x2;</span><br><span class="line">    <span class="keyword">float</span> alpha, beta;</span><br><span class="line">    <span class="keyword">float</span> area;</span><br><span class="line">&#125; Segment;</span><br></pre></td></tr></table></figure></p>
<p>结构体<code>Interval</code>保存了区间 $[ x_i, x_{i+1} ]$ 上的envelope上下界，包含下界一段和上界（至多）两段线段的信息。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x1, x2;</span><br><span class="line">    <span class="keyword">double</span> alpha, beta;</span><br><span class="line">    Position flag;</span><br><span class="line">    Segment leftseg, rightseg;</span><br><span class="line">&#125; Interval;</span><br></pre></td></tr></table></figure></p>
<p>最后我们使用二叉搜索树来组织这些<code>Interval</code>，节点的序关系由区间的前后定义。二叉树的实现使得对分段函数的查找和求值达到 $log(n)$ 的时间复杂度。</p>
<p>生成随机数的函数<code>rars()</code>接受一个指向求密度函数对数的函数指针<code>(*log_density)(double)</code> ，不同的函数指针可以包装成不同的随机数函数。</p>
<p>下面的Gist显式了部分核心代码，完整的源代码参见 <a href="https://github.com/vonweber0616/ARS" target="_blank" rel="noopener">GitHub仓库</a>。</p>
<p>最后值得一提的是ARS的算法我觉得唯一的优点就是泛用性，因为许多有用的分布都是对数凹密度。ARS算法看起来很理想，但是在实现上的缺点是它包含大量动态内存操作，这些内存操作的开销已经远超过计算本身，此外由于ARS算法构造分段的envelope上下界，随着集合 $S_n$ 不断增大，对分段函数进行求值得开销也越来越大。所以我觉得不如一开始就设定一个充分大的集合 $S_n$，比如包含几百个分割点，无需再生成随机数过程中更新 $S_n$。</p>
<script src="//gist.github.com/141a5cb0e9229491c07b3442ae5bd841.js?file=ARS.c"></script>

	

	

</article>




	<article>
	
		<h1><a href="/2018/11/03/SIMD指令优化/">An Optimization with SIMD Instructions</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2018-11-03</span><br>
		
		
			<span class="article__tags">
			  	<a class="article__tag-link" href="/tags/AVX2/">AVX2</a> <a class="article__tag-link" href="/tags/C/">C</a> <a class="article__tag-link" href="/tags/SIMD/">SIMD</a> <a class="article__tag-link" href="/tags/汇编/">汇编</a>
			</span>
		
	</div>

	

	
		<p>本文介绍利用SIMD指令（AVX2）优化运算的一点探索，以单精度float类型的加法和乘法为例。</p>
<p>计算模型：</p>
<ul>
<li>hardware: E5 2678 v3 2.5GHz; X99; DDR4 2133 MHz 16GB x1</li>
<li>software: win10 17134; mingw-W64(gcc) 8.1.0</li>
</ul>
<h2 id="SIMD和AVX2简介"><a href="#SIMD和AVX2简介" class="headerlink" title="SIMD和AVX2简介"></a>SIMD和AVX2简介</h2><p>SIMD (<strong>s</strong>ingle <strong>i</strong>nstrucion <strong>m</strong>ultiple <strong>d</strong>ata)单指令多数据是用来对多个数据执行单个指令（算术或逻辑）的向量化方法，是X86-64(AMD64)指令集的拓展。由最早的SSE（SSE有多个改进版本，最后的SSE版本是SSE4.2），到后来的AVX，AVX2，最新的是AVX512，由于AVX512在较新和高端的CPU才支持，相较而言，更多的CPU支持AVX2。</p>
<p>AVX2指令集配合16个256位ymm寄存器（低128位为xmm寄存器），可以存储8个4字节(float, int)或4个8字节(double, long)数据，并在一个指令内同时做8个或4个运算。</p>
<h2 id="Basic-Solution"><a href="#Basic-Solution" class="headerlink" title="Basic Solution"></a>Basic Solution</h2><p>现在来考虑一个任务，将长度均为<code>N = 100000</code>的float数组<code>a, b, c</code>做运算<code>(a + b) * c</code>，存放在数组r中。将这个操作重复<code>NTIME = 50000</code>次，记录消耗的时间。</p>
<p>由于这个任务作为编程问题是如此的简单和直接，我们很快写出c程序如<code>code 0: simd0.c</code>，并觉得毫无优化的余地，因为仅有三行代码没有任何多余的操作，只有17,19,20三行代码是在完成任务。其中的变量<code>sum</code>仅仅是用来防止编译器的自动优化会直接去掉重复50000次这个步骤，虽然这个优化很厉害，但是偏离了我们的原意。</p>
<p>使用命令<code>gcc simd0.c -o simd0.exe</code>编译，运行时间为<code>13s 803ms 846μs</code>，取5次计算的中位数，下同。如果我们满足于这个结果，觉得已经很快了，那生活也就没有了乐趣。</p>
<figure class="highlight c"><figcaption><span>code 0: simd0.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NTIMES 50000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> a[N], b[N], c[N], r[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, times, sum;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">starttime</span>, <span class="title">endtime</span>;</span></span><br><span class="line">    <span class="keyword">long</span> s, ms, us, timeuse;</span><br><span class="line">    gettimeofday(&amp;starttime, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* workhorse code  */</span></span><br><span class="line">    <span class="keyword">for</span> (times = <span class="number">0</span>; times &lt; NTIMES; times++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            r[i] = (a[i] + b[i]) * c[i];</span><br><span class="line">        sum += sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* elapsed time  */</span></span><br><span class="line">    gettimeofday(&amp;endtime, <span class="number">0</span>);</span><br><span class="line">    timeuse = <span class="number">1000000</span> * (endtime.tv_sec - starttime.tv_sec) + </span><br><span class="line">            endtime.tv_usec - starttime.tv_usec;</span><br><span class="line">    s = timeuse / <span class="number">1000000</span>;</span><br><span class="line">    ms = timeuse / <span class="number">1000</span> % <span class="number">1000</span>;</span><br><span class="line">    us = timeuse % <span class="number">1000</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld s %ld ms %ld us\n"</span>, s, ms, us);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="GCC自动优化"><a href="#GCC自动优化" class="headerlink" title="GCC自动优化"></a>GCC自动优化</h2><p>我们可以用命令<code>gcc -S -o simd0.s simd0.c</code>生成上述程序<code>simd0.exe</code>的汇编代码，看看哪里可以优化，其实这个汇编的蠢不在于没有用SIMD指令，主要问题是有太多的访问内存指令，代码没有贴出来。</p>
<p>如果我们使用<code>-O1</code>参数进行优化，即<code>gcc -O1 -o simd0-O1.exe simd0.c</code>，消耗的时间下降为<code>3s 841ms 346μs</code>。汇编代码如<code>code 1: simd0-O1.s</code>, 其中略去了计时，打印和某些伪指令，下同。<br><figure class="highlight x86asm"><figcaption><span>code 1: simd0-O1.s</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">main:</span></span><br><span class="line">  movl <span class="number">$50000</span>, %edx</span><br><span class="line">  <span class="keyword">jmp</span> .L2</span><br><span class="line"><span class="symbol">.L6:</span></span><br><span class="line">  <span class="keyword">addss</span> %xmm1, %xmm1</span><br><span class="line">  subl <span class="number">$1</span>, %edx</span><br><span class="line">  <span class="keyword">je</span> .L4</span><br><span class="line"><span class="symbol">.L2:</span></span><br><span class="line">  movl <span class="number">$0</span>, %eax</span><br><span class="line"><span class="symbol">.L3:</span></span><br><span class="line">  <span class="keyword">movss</span> a(%rax), %xmm0</span><br><span class="line">  <span class="keyword">addss</span> b(%rax), %xmm0</span><br><span class="line">  <span class="keyword">mulss</span> c(%rax), %xmm0</span><br><span class="line">  <span class="keyword">movss</span> %xmm0, r(%rax)</span><br><span class="line">  addq <span class="number">$4</span>, %rax</span><br><span class="line">  cmpq <span class="number">$400000</span>, %rax</span><br><span class="line">  <span class="keyword">jne</span> .L3</span><br><span class="line">  <span class="keyword">jmp</span> .L6</span><br><span class="line"><span class="symbol">.L4:</span></span><br><span class="line">  <span class="keyword">cvttss2si</span> %xmm1, %eax</span><br><span class="line">  <span class="keyword">ret</span></span><br></pre></td></tr></table></figure></p>
<p><code>simd0-O1.s</code>的代码和不使用优化的代码相比，主要改进是从内存中取一个数比如<code>a[i]</code>，只需要一次访存，因为指标<code>i</code>存在寄存器<code>%rax</code>中，这一个改进大幅降低了访问指标<code>i</code>和数组元素<code>a[i]</code>和其他数组的时间。<code>simd0-O1.s</code>的代码非常符合我们思维，它使用<code>movss</code>从内存中取一个单精度数，使用<code>addss</code>和<code>mulss</code>执行单精度浮点数的加法和乘法。执行一遍计算后再做第二遍。</p>
<p>使用<code>-O2</code>优化和<code>-O1</code>对这个程序没有太大差异，我们略去。</p>
<h2 id="SIMD的第一尝试"><a href="#SIMD的第一尝试" class="headerlink" title="SIMD的第一尝试"></a>SIMD的第一尝试</h2><p>如果我们使用<code>-O3</code>级别优化，就会放发生某些不一样的事情，汇编代码见<code>code 2: simd0-O3.s</code><br><figure class="highlight x86asm"><figcaption><span>code 2: simd0-O3.s</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">main:</span></span><br><span class="line">  movl <span class="number">$50000</span>, %edx</span><br><span class="line"><span class="symbol">.L2:</span></span><br><span class="line">  xorl %eax, %eax</span><br><span class="line"><span class="symbol">.L3:</span></span><br><span class="line">  <span class="keyword">movaps</span> b(%rax), %xmm0</span><br><span class="line">  <span class="keyword">addps</span> a(%rax), %xmm0</span><br><span class="line">  addq <span class="number">$16</span>, %rax</span><br><span class="line">  <span class="keyword">mulps</span> c-<span class="number">16</span>(%rax), %xmm0</span><br><span class="line">  <span class="keyword">movaps</span> %xmm0, r-<span class="number">16</span>(%rax)</span><br><span class="line">  cmpq <span class="number">$400000</span>, %rax</span><br><span class="line">  <span class="keyword">jne</span> .L3</span><br><span class="line">  <span class="keyword">addss</span> %xmm1, %xmm1</span><br><span class="line">  subl <span class="number">$1</span>, %edx</span><br><span class="line">  <span class="keyword">jne</span> .L2</span><br><span class="line">  <span class="keyword">cvttss2si</span> %xmm1, %eax</span><br><span class="line">  <span class="keyword">ret</span></span><br></pre></td></tr></table></figure></p>
<p>和<code>code 1: simd0-O2.s</code>相比，<code>code 2: simd0-O3.s</code>代码启用了SSE指令集的SIMD指令，它使用完整的<code>xmm</code>寄存器，而不是低32位，进行浮点数的加法和乘法。其中，<code>movaps</code>从内存中取4个单精度浮点数放在<code>xmm</code>寄存器中，或者相反方向，<code>addps</code>和<code>mulps</code>分别对<code>xmm</code>寄存器中的4个单精度数据做加法和乘法。使用SSE指令，运行时间又降为<code>2s 612ms 38μs</code>。</p>
<h2 id="AVX2上场"><a href="#AVX2上场" class="headerlink" title="AVX2上场"></a>AVX2上场</h2><p>虽然我们仍然可以使用参数让编译器自动向量化，比如<code>gcc -O3 -maxv2 -o simd1-avx2-O3.exe simd0.c</code>，但是这样的优化结果是不可预测的，因此在编程的时候使用适当的机制或约定引导编译器进行向量化，是更加稳健的方法。</p>
<h3 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h3><p>将变量的存储地址对齐到8/16/32/64等整数的倍数，是某些指令的要求，同时可以使寻址更加有效。在GCC环境下，使用<code>__attribute__((aligned(__BIGGEST_ALIGNMENT__)))</code>修饰符引导编译器进行内存对齐。比如声明长度为N的float数组，对齐到64字节<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> a[N] __attribute__((aligned(<span class="number">64</span>)));</span><br></pre></td></tr></table></figure></p>
<h3 id="向量数据类型"><a href="#向量数据类型" class="headerlink" title="向量数据类型"></a>向量数据类型</h3><p>在GCC环境下，可以声明基本数据类型<code>char, int, float, double, long</code>的数组作为向量，来引导编译器使用SIMD指令编译，比如下面的代码声明了一种8个float长的向量类型<code>v8f</code>，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">float</span> v8f __attribute__((vector_size(<span class="number">32</span>)));</span><br></pre></td></tr></table></figure></p>
<p>向量数据类型可以使用运算符<code>+ - * / &amp; ^ | %</code>等进行逐元素运算，他们会被编译成相应的SIMD指令。</p>
<p>现在我们可以利用上面的技巧，来重写程序，确保我们使用了SIMD指令，见<code>code 3: simd1.c</code><br><figure class="highlight c"><figcaption><span>code 3: simd1.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NTIMES 50000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGN 64</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">float</span> v8f __attribute__((vector_size(<span class="number">32</span>)));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VLEN (sizeof(v8f) / sizeof(float))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> a[N] __attribute__((aligned(ALIGN)));</span><br><span class="line"><span class="keyword">float</span> b[N] __attribute__((aligned(ALIGN)));</span><br><span class="line"><span class="keyword">float</span> c[N] __attribute__((aligned(ALIGN)));</span><br><span class="line"><span class="keyword">float</span> r[N] __attribute__((aligned(ALIGN)));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    v8f *va, *vb, *vc, *vr;</span><br><span class="line">    <span class="keyword">int</span> i, times, sum;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">starttime</span>, <span class="title">endtime</span>;</span></span><br><span class="line">    <span class="keyword">long</span> s, ms, us, timeuse;</span><br><span class="line">    gettimeofday(&amp;starttime, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* workhorse code  */</span></span><br><span class="line">    <span class="keyword">for</span> (times = <span class="number">0</span>; times &lt; NTIMES; times++)</span><br><span class="line">    &#123;</span><br><span class="line">        va = (v8f *)a;</span><br><span class="line">        vb = (v8f *)b;</span><br><span class="line">        vc = (v8f *)c;</span><br><span class="line">        vr = (v8f *)r;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i += VLEN)&#123;</span><br><span class="line">            *vr = (*va + *vb) * (*vc);</span><br><span class="line">            va++, vb++, vc++, vr++;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* elapsed time  */</span></span><br><span class="line">    gettimeofday(&amp;endtime, <span class="number">0</span>);</span><br><span class="line">    timeuse = <span class="number">1000000</span> * (endtime.tv_sec - starttime.tv_sec) + </span><br><span class="line">    endtime.tv_usec - starttime.tv_usec;</span><br><span class="line">    s = timeuse / <span class="number">1000000</span>;</span><br><span class="line">    ms = timeuse / <span class="number">1000</span> % <span class="number">1000</span>;</span><br><span class="line">    us = timeuse % <span class="number">1000</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld s %ld ms %ld us\n"</span>, s, ms, us);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的程序使用指向向量数据类型<code>v8f</code>的指针来进行运算，这些操作可以很好的编译成SIMD指令。并且由于向量长度是8的整数倍，所以我们不用额外的操作。使用命令<code>gcc -mavx2 -O3 -S -o simd1-O3.s simd1.c</code>编译，得到和我们预想一样的汇编代码<br><figure class="highlight x86asm"><figcaption><span>code 4: simd1-O3.s</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">main:</span></span><br><span class="line">  xorl %eax, %eax</span><br><span class="line">  movl <span class="number">$50000</span>, %ecx</span><br><span class="line"><span class="symbol">.L3:</span></span><br><span class="line">  xorl %edx, %edx</span><br><span class="line"><span class="symbol">.L2:</span></span><br><span class="line">  <span class="keyword">vmovaps</span> a(%rdx), %ymm1</span><br><span class="line">  <span class="keyword">vaddps</span> b(%rdx), %ymm1, %ymm0</span><br><span class="line">  addq <span class="number">$32</span>, %rdx</span><br><span class="line">  <span class="keyword">vmulps</span> c-<span class="number">32</span>(%rdx), %ymm0, %ymm0</span><br><span class="line">  <span class="keyword">vmovaps</span> %ymm0, r-<span class="number">32</span>(%rdx)</span><br><span class="line">  cmpq <span class="number">$400000</span>, %rdx</span><br><span class="line">  <span class="keyword">jne</span> .L2</span><br><span class="line">  addl %eax, %eax</span><br><span class="line">  subl <span class="number">$1</span>, %ecx</span><br><span class="line">  <span class="keyword">jne</span> .L3</span><br><span class="line">  <span class="keyword">vzeroupper</span></span><br><span class="line">  <span class="keyword">ret</span></span><br></pre></td></tr></table></figure></p>
<p>和<code>code 2: simd0-O3.s</code>不同的是，这里使用指令<code>vmovaps vaddps vmulps</code>对8个（组）float数据进行操作。可惜的是，虽然我们一顿操作猛如虎，但是效率提升并不明显，原因是因为这个例子中，最费时的是内存的读写而不是计算加法和乘法。</p>
<p>如果我们换一个顺序，对于某个i，我们重复<code>NTIMES</code>次<code>r[i] = (a[i] + b[i]) * c[i]</code>操作，然后在进行下一个i，由于编译器优化总是会去掉一层循环，所以我们直接修改汇编代码如下<br><figure class="highlight x86asm"><figcaption><span>code 5: simd2-0.s</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">main:</span></span><br><span class="line"><span class="symbol">.L2:</span></span><br><span class="line">    movl	<span class="number">$50000</span>, %eax</span><br><span class="line"><span class="symbol">.L3:</span></span><br><span class="line">    <span class="keyword">vmovaps</span>	a(%rdx), %ymm1</span><br><span class="line">    <span class="keyword">vaddps</span>	b(%rdx), %ymm1, %ymm0</span><br><span class="line">    <span class="keyword">vmulps</span>	c(%rdx), %ymm0, %ymm0</span><br><span class="line"><span class="meta">    .p2align</span> <span class="number">4</span>,,<span class="number">10</span></span><br><span class="line">    addl	%ebx, %ebx</span><br><span class="line">    <span class="keyword">vmovaps</span>	%ymm0, r(%rdx)</span><br><span class="line">    subl	<span class="number">$1</span>, %eax</span><br><span class="line">    <span class="keyword">jne</span>	.L3</span><br><span class="line">    addq	<span class="number">$32</span>, %rdx</span><br><span class="line">    cmpq	<span class="number">$400000</span>, %rdx</span><br><span class="line">    <span class="keyword">jne</span>	.L2</span><br><span class="line">    xorl	%edx, %edx</span><br><span class="line">    <span class="keyword">vzeroupper</span></span><br><span class="line">    <span class="keyword">ret</span></span><br></pre></td></tr></table></figure></p>
<p>用命令<code>gcc -o simd2-0.exe simd2-0.s</code>将汇编指令链接成二进制程序。虽然只是调换了两个循环的顺序，操作也没有少一个，但是由于L1/2/3 cache的存在，<code>code 5</code>显著降低了访问内存的次数，执行时间仅为<code>0s 634ms 562μs</code>，验证了我们上面关于效率瓶颈的论断。</p>
<p>如果我们显式地先读一次数据到寄存器中，做<code>NTIMES</code>次计算，最后再写到内存中，这样就避免了多次读写内存的操作。汇编代码如下<br><figure class="highlight x86asm"><figcaption><span>code 6: simd2-1.s</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">main:</span></span><br><span class="line"><span class="symbol">.L2:</span></span><br><span class="line">    movl	<span class="number">$50000</span>, %eax</span><br><span class="line">    <span class="keyword">vmovaps</span>	a(%rdx), %ymm1</span><br><span class="line">    <span class="keyword">vmovaps</span>	b(%rdx), %ymm2</span><br><span class="line">    <span class="keyword">vmovaps</span>	c(%rdx), %ymm3</span><br><span class="line"><span class="symbol">.L3:</span></span><br><span class="line">    <span class="keyword">vaddps</span>	%ymm2, %ymm1, %ymm0</span><br><span class="line">    <span class="keyword">vmulps</span>	%ymm3, %ymm0, %ymm0</span><br><span class="line"><span class="meta">    .p2align</span> <span class="number">4</span>,,<span class="number">10</span></span><br><span class="line">    addl	%ebx, %ebx</span><br><span class="line">    <span class="keyword">vmovaps</span>	%ymm0, r(%rdx)</span><br><span class="line">    subl	<span class="number">$1</span>, %eax</span><br><span class="line">    <span class="keyword">jne</span>	.L3</span><br><span class="line">    addq	<span class="number">$32</span>, %rdx</span><br><span class="line">    cmpq	<span class="number">$400000</span>, %rdx</span><br><span class="line">    <span class="keyword">jne</span>	.L2</span><br><span class="line">    xorl	%edx, %edx</span><br><span class="line">    <span class="keyword">vzeroupper</span></span><br><span class="line">    <span class="keyword">ret</span></span><br></pre></td></tr></table></figure></p>
<p>最后优化的程序执行时间为<code>0s 324ms 504μs</code>。和最初的13.8s相比，这个速度快了40多倍，虽然主要功劳并不归功于SIMD指令，但是合理的SIMD向量化有助于我们减少内存的访问，从而为程序加速。</p>

	

	

</article>




	<article>
	
		<h1><a href="/2018/11/02/Hexo测试/">Hexo Blog Test</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2018-11-02</span><br>
		
		
			<span class="article__tags">
			  	<a class="article__tag-link" href="/tags/test/">test</a>
			</span>
		
	</div>

	

	
		<h1 id="1级标题-title"><a href="#1级标题-title" class="headerlink" title="1级标题 title"></a>1级标题 title</h1><h2 id="2级标题"><a href="#2级标题" class="headerlink" title="2级标题"></a>2级标题</h2><h3 id="3级标题"><a href="#3级标题" class="headerlink" title="3级标题"></a>3级标题</h3><p>正文，字体。</p>
<p>代码样式，引用<code>vmulpd</code>和<code>指令集</code>。<em>强调</em>和<strong>强调</strong><br><strong>instruction INSTRUCTION</strong><br><figure class="highlight c"><figcaption><span>vsum.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">vsum</span><span class="params">(<span class="keyword">float</span> *v, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> s = <span class="number">0.0</span>; <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    s += v[i];</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>MathJax test.<br>When \(a \ne 0\), there are two solutions to $ax^2 + bx + c = 0$ and they are<br>inline symbols, $\LaTeX \And \alpha$ and<br>  $$x = {-b \pm \sqrt{b^2-4ac} \over 2a}.$$</p>
<figure class="highlight html"><figcaption><span>add MathJax support</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/x-mathjax-config"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  MathJax.Hub.Config(&#123;tex2jax: &#123;inlineMath: [['$','$'], ['\\(','\\)']]&#125;&#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'https://cdnjs.cloudflare.com/ajax/libs/</span></span></span><br><span class="line"><span class="tag"><span class="string">mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML'</span> <span class="attr">async</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

	

	

</article>




	<article>
	
		<h1><a href="/2018/11/02/hello-world/">Hello World</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2018-11-02</span><br>
		
		
	</div>

	

	
		<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

	

	

</article>






	<span class="different-posts">📕 end of posts 📕</span>


	</main>

	<footer class="footer">
	<div class="footer-content">
		
	      <div class="footer__element">
	<p>Hi there, <br>welcome to my Blog glad you found it. Have a look around, will you?</p>
</div>

	    
	      <div class="footer__element">
	<h5>Check out</h5>
	<ul class="footer-links">
		<li class="footer-links__link"><a href="/archives">Archive</a></li>
		
		  <li class="footer-links__link"><a href="/atom.xml">RSS</a></li>
	    
		<li class="footer-links__link"><a href="/about">about page</a></li>
		<li class="footer-links__link"><a href="/tags">Tags</a></li>
		<li class="footer-links__link"><a href="/categories">Categories</a></li>
	</ul>
</div>

	    

		<div class="footer-credit">
			<span>© 2018 von Weber | Powered by <a href="https://hexo.io/">Hexo</a> | Theme <a href="https://github.com/HoverBaum/meilidu-hexo">MeiliDu</a></span>
		</div>

	</div>


</footer>



</body>

</html>
